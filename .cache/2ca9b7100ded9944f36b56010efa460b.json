{"dependencies":[{"name":"/Users/willemolding/repos/panoptipong/node_modules/tape/package.json","includedInParent":true,"mtime":1529950349322},{"name":"/Users/willemolding/repos/panoptipong/package.json","includedInParent":true,"mtime":1529952454752},{"name":"/Users/willemolding/repos/panoptipong/.babelrc","includedInParent":true,"mtime":1529950097751},{"name":"deep-equal","loc":{"line":1,"column":24},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/deep-equal/index.js"},{"name":"defined","loc":{"line":2,"column":22},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/defined/index.js"},{"name":"path","loc":{"line":3,"column":19},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/path-browserify/index.js"},{"name":"inherits","loc":{"line":4,"column":23},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/inherits/inherits_browser.js"},{"name":"events","loc":{"line":5,"column":27},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/events/events.js"},{"name":"has","loc":{"line":6,"column":18},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/has/src/index.js"},{"name":"string.prototype.trim","loc":{"line":7,"column":19},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/string.prototype.trim/index.js"},{"name":"function-bind","loc":{"line":8,"column":19},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/function-bind/index.js"},{"name":"for-each","loc":{"line":9,"column":22},"parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/for-each/index.js"},{"name":"process","parent":"/Users/willemolding/repos/panoptipong/node_modules/tape/lib/test.js","resolved":"/Users/willemolding/repos/panoptipong/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\nvar __dirname = \"/Users/willemolding/repos/panoptipong/node_modules/tape/lib\";\nvar deepEqual = require('deep-equal');\nvar defined = require('defined');\nvar path = require('path');\nvar inherits = require('inherits');\nvar EventEmitter = require('events').EventEmitter;\nvar has = require('has');\nvar trim = require('string.prototype.trim');\nvar bind = require('function-bind');\nvar forEach = require('for-each');\nvar isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);\nvar toLowerCase = bind.call(Function.call, String.prototype.toLowerCase);\n\nmodule.exports = Test;\n\nvar nextTick = typeof setImmediate !== 'undefined' ? setImmediate : process.nextTick;\nvar safeSetTimeout = setTimeout;\nvar safeClearTimeout = clearTimeout;\n\ninherits(Test, EventEmitter);\n\nvar getTestArgs = function (name_, opts_, cb_) {\n    var name = '(anonymous)';\n    var opts = {};\n    var cb;\n\n    for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        var t = typeof arg;\n        if (t === 'string') {\n            name = arg;\n        } else if (t === 'object') {\n            opts = arg || opts;\n        } else if (t === 'function') {\n            cb = arg;\n        }\n    }\n    return { name: name, opts: opts, cb: cb };\n};\n\nfunction Test(name_, opts_, cb_) {\n    if (!(this instanceof Test)) {\n        return new Test(name_, opts_, cb_);\n    }\n\n    var args = getTestArgs(name_, opts_, cb_);\n\n    this.readable = true;\n    this.name = args.name || '(anonymous)';\n    this.assertCount = 0;\n    this.pendingCount = 0;\n    this._skip = args.opts.skip || false;\n    this._timeout = args.opts.timeout;\n    this._plan = undefined;\n    this._cb = args.cb;\n    this._progeny = [];\n    this._ok = true;\n    var depthEnvVar = undefined;\n    if (args.opts.objectPrintDepth) {\n        this._objectPrintDepth = args.opts.objectPrintDepth;\n    } else if (depthEnvVar) {\n        if (toLowerCase(depthEnvVar) === 'infinity') {\n            this._objectPrintDepth = Infinity;\n        } else {\n            this._objectPrintDepth = depthEnvVar;\n        }\n    } else {\n        this._objectPrintDepth = 5;\n    }\n\n    for (var prop in this) {\n        this[prop] = function bind(self, val) {\n            if (typeof val === 'function') {\n                return function bound() {\n                    return val.apply(self, arguments);\n                };\n            }\n            return val;\n        }(this, this[prop]);\n    }\n}\n\nTest.prototype.run = function () {\n    if (this._skip) {\n        this.comment('SKIP ' + this.name);\n    }\n    if (!this._cb || this._skip) {\n        return this._end();\n    }\n    if (this._timeout != null) {\n        this.timeoutAfter(this._timeout);\n    }\n    this.emit('prerun');\n    this._cb(this);\n    this.emit('run');\n};\n\nTest.prototype.test = function (name, opts, cb) {\n    var self = this;\n    var t = new Test(name, opts, cb);\n    this._progeny.push(t);\n    this.pendingCount++;\n    this.emit('test', t);\n    t.on('prerun', function () {\n        self.assertCount++;\n    });\n\n    if (!self._pendingAsserts()) {\n        nextTick(function () {\n            self._end();\n        });\n    }\n\n    nextTick(function () {\n        if (!self._plan && self.pendingCount == self._progeny.length) {\n            self._end();\n        }\n    });\n};\n\nTest.prototype.comment = function (msg) {\n    var that = this;\n    forEach(trim(msg).split('\\n'), function (aMsg) {\n        that.emit('result', trim(aMsg).replace(/^#\\s*/, ''));\n    });\n};\n\nTest.prototype.plan = function (n) {\n    this._plan = n;\n    this.emit('plan', n);\n};\n\nTest.prototype.timeoutAfter = function (ms) {\n    if (!ms) throw new Error('timeoutAfter requires a timespan');\n    var self = this;\n    var timeout = safeSetTimeout(function () {\n        self.fail('test timed out after ' + ms + 'ms');\n        self.end();\n    }, ms);\n    this.once('end', function () {\n        safeClearTimeout(timeout);\n    });\n};\n\nTest.prototype.end = function (err) {\n    var self = this;\n    if (arguments.length >= 1 && !!err) {\n        this.ifError(err);\n    }\n\n    if (this.calledEnd) {\n        this.fail('.end() called twice');\n    }\n    this.calledEnd = true;\n    this._end();\n};\n\nTest.prototype._end = function (err) {\n    var self = this;\n    if (this._progeny.length) {\n        var t = this._progeny.shift();\n        t.on('end', function () {\n            self._end();\n        });\n        t.run();\n        return;\n    }\n\n    if (!this.ended) this.emit('end');\n    var pendingAsserts = this._pendingAsserts();\n    if (!this._planError && this._plan !== undefined && pendingAsserts) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected: this._plan,\n            actual: this.assertCount\n        });\n    }\n    this.ended = true;\n};\n\nTest.prototype._exit = function () {\n    if (this._plan !== undefined && !this._planError && this.assertCount !== this._plan) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected: this._plan,\n            actual: this.assertCount,\n            exiting: true\n        });\n    } else if (!this.ended) {\n        this.fail('test exited without ending', {\n            exiting: true\n        });\n    }\n};\n\nTest.prototype._pendingAsserts = function () {\n    if (this._plan === undefined) {\n        return 1;\n    }\n    return this._plan - (this._progeny.length + this.assertCount);\n};\n\nTest.prototype._assert = function assert(ok, opts) {\n    var self = this;\n    var extra = opts.extra || {};\n\n    var res = {\n        id: self.assertCount++,\n        ok: Boolean(ok),\n        skip: defined(extra.skip, opts.skip),\n        name: defined(extra.message, opts.message, '(unnamed assert)'),\n        operator: defined(extra.operator, opts.operator),\n        objectPrintDepth: self._objectPrintDepth\n    };\n    if (has(opts, 'actual') || has(extra, 'actual')) {\n        res.actual = defined(extra.actual, opts.actual);\n    }\n    if (has(opts, 'expected') || has(extra, 'expected')) {\n        res.expected = defined(extra.expected, opts.expected);\n    }\n    this._ok = Boolean(this._ok && ok);\n\n    if (!ok) {\n        res.error = defined(extra.error, opts.error, new Error(res.name));\n    }\n\n    if (!ok) {\n        var e = new Error('exception');\n        var err = (e.stack || '').split('\\n');\n        var dir = __dirname + path.sep;\n\n        for (var i = 0; i < err.length; i++) {\n            /*\n                Stack trace lines may resemble one of the following. We need\n                to should correctly extract a function name (if any) and\n                path / line no. for each line.\n                     at myFunction (/path/to/file.js:123:45)\n                    at myFunction (/path/to/file.other-ext:123:45)\n                    at myFunction (/path to/file.js:123:45)\n                    at myFunction (C:\\path\\to\\file.js:123:45)\n                    at myFunction (/path/to/file.js:123)\n                    at Test.<anonymous> (/path/to/file.js:123:45)\n                    at Test.bound [as run] (/path/to/file.js:123:45)\n                    at /path/to/file.js:123:45\n                 Regex has three parts. First is non-capturing group for 'at '\n                (plus anything preceding it).\n                     /^(?:[^\\s]*\\s*\\bat\\s+)/\n                 Second captures function call description (optional). This is\n                not necessarily a valid JS function name, but just what the\n                stack trace is using to represent a function call. It may look\n                like `<anonymous>` or 'Test.bound [as run]'.\n                 For our purposes, we assume that, if there is a function\n                name, it's everything leading up to the first open\n                parentheses (trimmed) before our pathname.\n                     /(?:(.*)\\s+\\()?/\n                 Last part captures file path plus line no (and optional\n                column no).\n                     /((?:\\/|[A-Z]:\\\\)[^:\\)]+:(\\d+)(?::(\\d+))?)/\n            */\n            var re = /^(?:[^\\s]*\\s*\\bat\\s+)(?:(.*)\\s+\\()?((?:\\/|[A-Z]:\\\\)[^:\\)]+:(\\d+)(?::(\\d+))?)/;\n            var m = re.exec(err[i]);\n\n            if (!m) {\n                continue;\n            }\n\n            var callDescription = m[1] || '<anonymous>';\n            var filePath = m[2];\n\n            if (filePath.slice(0, dir.length) === dir) {\n                continue;\n            }\n\n            // Function call description may not (just) be a function name.\n            // Try to extract function name by looking at first \"word\" only.\n            res.functionName = callDescription.split(/\\s+/)[0];\n            res.file = filePath;\n            res.line = Number(m[3]);\n            if (m[4]) res.column = Number(m[4]);\n\n            res.at = callDescription + ' (' + filePath + ')';\n            break;\n        }\n    }\n\n    self.emit('result', res);\n\n    var pendingAsserts = self._pendingAsserts();\n    if (!pendingAsserts) {\n        if (extra.exiting) {\n            self._end();\n        } else {\n            nextTick(function () {\n                self._end();\n            });\n        }\n    }\n\n    if (!self._planError && pendingAsserts < 0) {\n        self._planError = true;\n        self.fail('plan != count', {\n            expected: self._plan,\n            actual: self._plan - pendingAsserts\n        });\n    }\n};\n\nTest.prototype.fail = function (msg, extra) {\n    this._assert(false, {\n        message: msg,\n        operator: 'fail',\n        extra: extra\n    });\n};\n\nTest.prototype.pass = function (msg, extra) {\n    this._assert(true, {\n        message: msg,\n        operator: 'pass',\n        extra: extra\n    });\n};\n\nTest.prototype.skip = function (msg, extra) {\n    this._assert(true, {\n        message: msg,\n        operator: 'skip',\n        skip: true,\n        extra: extra\n    });\n};\n\nfunction assert(value, msg, extra) {\n    this._assert(value, {\n        message: defined(msg, 'should be truthy'),\n        operator: 'ok',\n        expected: true,\n        actual: value,\n        extra: extra\n    });\n}\nTest.prototype.ok = Test.prototype['true'] = Test.prototype.assert = assert;\n\nfunction notOK(value, msg, extra) {\n    this._assert(!value, {\n        message: defined(msg, 'should be falsy'),\n        operator: 'notOk',\n        expected: false,\n        actual: value,\n        extra: extra\n    });\n}\nTest.prototype.notOk = Test.prototype['false'] = Test.prototype.notok = notOK;\n\nfunction error(err, msg, extra) {\n    this._assert(!err, {\n        message: defined(msg, String(err)),\n        operator: 'error',\n        actual: err,\n        extra: extra\n    });\n}\nTest.prototype.error = Test.prototype.ifError = Test.prototype.ifErr = Test.prototype.iferror = error;\n\nfunction equal(a, b, msg, extra) {\n    this._assert(a === b, {\n        message: defined(msg, 'should be equal'),\n        operator: 'equal',\n        actual: a,\n        expected: b,\n        extra: extra\n    });\n}\nTest.prototype.equal = Test.prototype.equals = Test.prototype.isEqual = Test.prototype.is = Test.prototype.strictEqual = Test.prototype.strictEquals = equal;\n\nfunction notEqual(a, b, msg, extra) {\n    this._assert(a !== b, {\n        message: defined(msg, 'should not be equal'),\n        operator: 'notEqual',\n        actual: a,\n        notExpected: b,\n        extra: extra\n    });\n}\nTest.prototype.notEqual = Test.prototype.notEquals = Test.prototype.notStrictEqual = Test.prototype.notStrictEquals = Test.prototype.isNotEqual = Test.prototype.isNot = Test.prototype.not = Test.prototype.doesNotEqual = Test.prototype.isInequal = notEqual;\n\nfunction tapeDeepEqual(a, b, msg, extra) {\n    this._assert(deepEqual(a, b, { strict: true }), {\n        message: defined(msg, 'should be equivalent'),\n        operator: 'deepEqual',\n        actual: a,\n        expected: b,\n        extra: extra\n    });\n}\nTest.prototype.deepEqual = Test.prototype.deepEquals = Test.prototype.isEquivalent = Test.prototype.same = tapeDeepEqual;\n\nfunction deepLooseEqual(a, b, msg, extra) {\n    this._assert(deepEqual(a, b), {\n        message: defined(msg, 'should be equivalent'),\n        operator: 'deepLooseEqual',\n        actual: a,\n        expected: b,\n        extra: extra\n    });\n}\nTest.prototype.deepLooseEqual = Test.prototype.looseEqual = Test.prototype.looseEquals = deepLooseEqual;\n\nfunction notDeepEqual(a, b, msg, extra) {\n    this._assert(!deepEqual(a, b, { strict: true }), {\n        message: defined(msg, 'should not be equivalent'),\n        operator: 'notDeepEqual',\n        actual: a,\n        notExpected: b,\n        extra: extra\n    });\n}\nTest.prototype.notDeepEqual = Test.prototype.notEquivalent = Test.prototype.notDeeply = Test.prototype.notSame = Test.prototype.isNotDeepEqual = Test.prototype.isNotDeeply = Test.prototype.isNotEquivalent = Test.prototype.isInequivalent = notDeepEqual;\n\nfunction notDeepLooseEqual(a, b, msg, extra) {\n    this._assert(!deepEqual(a, b), {\n        message: defined(msg, 'should be equivalent'),\n        operator: 'notDeepLooseEqual',\n        actual: a,\n        expected: b,\n        extra: extra\n    });\n}\nTest.prototype.notDeepLooseEqual = Test.prototype.notLooseEqual = Test.prototype.notLooseEquals = notDeepLooseEqual;\n\nTest.prototype['throws'] = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n\n    var caught = undefined;\n\n    try {\n        fn();\n    } catch (err) {\n        caught = { error: err };\n        if (err != null && (!isEnumerable(err, 'message') || !has(err, 'message'))) {\n            var message = err.message;\n            delete err.message;\n            err.message = message;\n        }\n    }\n\n    var passed = caught;\n\n    if (expected instanceof RegExp) {\n        passed = expected.test(caught && caught.error);\n        expected = String(expected);\n    }\n\n    if (typeof expected === 'function' && caught) {\n        passed = caught.error instanceof expected;\n        caught.error = caught.error.constructor;\n    }\n\n    this._assert(typeof fn === 'function' && passed, {\n        message: defined(msg, 'should throw'),\n        operator: 'throws',\n        actual: caught && caught.error,\n        expected: expected,\n        error: !passed && caught && caught.error,\n        extra: extra\n    });\n};\n\nTest.prototype.doesNotThrow = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n    var caught = undefined;\n    try {\n        fn();\n    } catch (err) {\n        caught = { error: err };\n    }\n    this._assert(!caught, {\n        message: defined(msg, 'should not throw'),\n        operator: 'throws',\n        actual: caught && caught.error,\n        expected: expected,\n        error: caught && caught.error,\n        extra: extra\n    });\n};\n\nTest.skip = function (name_, _opts, _cb) {\n    var args = getTestArgs.apply(null, arguments);\n    args.opts.skip = true;\n    return Test(args.name, args.opts, args.cb);\n};\n\n// vim: set softtabstop=4 shiftwidth=4:","map":null},"hash":"71ad19604644f0cd21bfbbc1e52e0738","cacheData":{"env":{}},"id":198}